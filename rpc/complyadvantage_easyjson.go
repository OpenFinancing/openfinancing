// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package rpc

import (
	json "encoding/json"
	easyjson "github.com/mailru/easyjson"
	jlexer "github.com/mailru/easyjson/jlexer"
	jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

func easyjsonD017d1f1DecodeGithubComYaleOpenLabOpenxRpc(in *jlexer.Lexer, out *caAllUserResponse) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "code":
			out.Code = int(in.Int())
		case "status":
			out.Status = string(in.String())
		case "content":
			easyjsonD017d1f1Decode(in, &out.Content)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD017d1f1EncodeGithubComYaleOpenLabOpenxRpc(out *jwriter.Writer, in caAllUserResponse) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"code\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int(int(in.Code))
	}
	{
		const prefix string = ",\"status\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Status))
	}
	{
		const prefix string = ",\"content\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		easyjsonD017d1f1Encode(out, in.Content)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v caAllUserResponse) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonD017d1f1EncodeGithubComYaleOpenLabOpenxRpc(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v caAllUserResponse) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonD017d1f1EncodeGithubComYaleOpenLabOpenxRpc(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *caAllUserResponse) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonD017d1f1DecodeGithubComYaleOpenLabOpenxRpc(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *caAllUserResponse) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonD017d1f1DecodeGithubComYaleOpenLabOpenxRpc(l, v)
}
func easyjsonD017d1f1Decode(in *jlexer.Lexer, out *struct {
	Data []struct {
		Id         int    `json:"id"`
		Email      string `json:"email"`
		Name       string `json:"name"`
		Phone      string `json:"phone"`
		Updated_at string `json:"updated_at"`
		Created_at string `json:"created_at"`
	} `json:"data"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "data":
			if in.IsNull() {
				in.Skip()
				out.Data = nil
			} else {
				in.Delim('[')
				if out.Data == nil {
					if !in.IsDelim(']') {
						out.Data = make([]struct {
							Id         int    `json:"id"`
							Email      string `json:"email"`
							Name       string `json:"name"`
							Phone      string `json:"phone"`
							Updated_at string `json:"updated_at"`
							Created_at string `json:"created_at"`
						}, 0, 1)
					} else {
						out.Data = []struct {
							Id         int    `json:"id"`
							Email      string `json:"email"`
							Name       string `json:"name"`
							Phone      string `json:"phone"`
							Updated_at string `json:"updated_at"`
							Created_at string `json:"created_at"`
						}{}
					}
				} else {
					out.Data = (out.Data)[:0]
				}
				for !in.IsDelim(']') {
					var v1 struct {
						Id         int    `json:"id"`
						Email      string `json:"email"`
						Name       string `json:"name"`
						Phone      string `json:"phone"`
						Updated_at string `json:"updated_at"`
						Created_at string `json:"created_at"`
					}
					easyjsonD017d1f1Decode1(in, &v1)
					out.Data = append(out.Data, v1)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD017d1f1Encode(out *jwriter.Writer, in struct {
	Data []struct {
		Id         int    `json:"id"`
		Email      string `json:"email"`
		Name       string `json:"name"`
		Phone      string `json:"phone"`
		Updated_at string `json:"updated_at"`
		Created_at string `json:"created_at"`
	} `json:"data"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"data\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Data == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v2, v3 := range in.Data {
				if v2 > 0 {
					out.RawByte(',')
				}
				easyjsonD017d1f1Encode1(out, v3)
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}
func easyjsonD017d1f1Decode1(in *jlexer.Lexer, out *struct {
	Id         int    `json:"id"`
	Email      string `json:"email"`
	Name       string `json:"name"`
	Phone      string `json:"phone"`
	Updated_at string `json:"updated_at"`
	Created_at string `json:"created_at"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "id":
			out.Id = int(in.Int())
		case "email":
			out.Email = string(in.String())
		case "name":
			out.Name = string(in.String())
		case "phone":
			out.Phone = string(in.String())
		case "updated_at":
			out.Updated_at = string(in.String())
		case "created_at":
			out.Created_at = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD017d1f1Encode1(out *jwriter.Writer, in struct {
	Id         int    `json:"id"`
	Email      string `json:"email"`
	Name       string `json:"name"`
	Phone      string `json:"phone"`
	Updated_at string `json:"updated_at"`
	Created_at string `json:"created_at"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"id\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int(int(in.Id))
	}
	{
		const prefix string = ",\"email\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Email))
	}
	{
		const prefix string = ",\"name\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Name))
	}
	{
		const prefix string = ",\"phone\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Phone))
	}
	{
		const prefix string = ",\"updated_at\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Updated_at))
	}
	{
		const prefix string = ",\"created_at\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Created_at))
	}
	out.RawByte('}')
}
func easyjsonD017d1f1DecodeGithubComYaleOpenLabOpenxRpc1(in *jlexer.Lexer, out *CAResponse) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "code":
			out.Code = int(in.Int())
		case "string":
			out.Status = string(in.String())
		case "content":
			easyjsonD017d1f1Decode2(in, &out.Content)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD017d1f1EncodeGithubComYaleOpenLabOpenxRpc1(out *jwriter.Writer, in CAResponse) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"code\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int(int(in.Code))
	}
	{
		const prefix string = ",\"string\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Status))
	}
	{
		const prefix string = ",\"content\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		easyjsonD017d1f1Encode2(out, in.Content)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v CAResponse) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonD017d1f1EncodeGithubComYaleOpenLabOpenxRpc1(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v CAResponse) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonD017d1f1EncodeGithubComYaleOpenLabOpenxRpc1(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *CAResponse) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonD017d1f1DecodeGithubComYaleOpenLabOpenxRpc1(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *CAResponse) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonD017d1f1DecodeGithubComYaleOpenLabOpenxRpc1(l, v)
}
func easyjsonD017d1f1Decode2(in *jlexer.Lexer, out *struct {
	Data struct {
		Id          int64  `json:"id"`
		Ref         string `json:"ref"`
		Searcher_id int64  `json:"searcher_id"`
		Assignee_id int64  `json:"assignee_id"`
		Filters     struct {
			Birth_year      int64    `json:"birth_year"`
			Country_codes   []int    `json:"country_codes"`
			Remove_deceased int      `json:"remove_deceased"`
			Types           []string `json:"types"`
			Exact_match     bool     `json:"exact_match"`
			Fuzziness       float64  `json:"fuzziness"`
		}
		Match_status   string   `json:"match_status"`
		Risk_level     string   `json:"risk_level"`
		Search_term    string   `json:"search_term"`
		Submitted_term string   `json:"submitted_term"`
		Client_ref     string   `json:"client_ref"`
		Total_hits     int      `json:"total_hits"`
		Updated_at     string   `json:"updated_at"`
		Created_at     string   `json:"created_at"`
		Tags           []string `json:"tags"`
		Limit          int      `json:"limit"`
		Offset         int      `json:"offset"`
		Share_url      string   `json:"share_url"`
		Hits           []struct {
			Doc struct {
				Aka []struct {
					Name string `json:"name"`
				} `json:"aka"`
				Assets []struct {
					Public_url string `json:"public_url"`
					Source     string `json:"source"`
					Type       string `json:"type"`
				} `json:"assets"`
				Entity_type string `json:"entity_type"`
				Fields      []struct {
					Name   string `json:"name"`
					Source string `json:"source"`
					Tag    string `json:"tag"`
					Value  string `json:"value"`
				} `json:"fields"`
				Id    string
				Media []struct {
					Date    string `json:"date"`
					Snippet string `json:"snippet"`
					Title   string `json:"title"`
					Url     string `json:"url"`
				} `json:"media"`
				Name    string   `json:"name"`
				Sources []string `json:"sources"`
				Types   []string `json:"types"`
			} `json:"doc"`
			Match_types    []string `json:"match_types"`
			Score          float64  `json:"score"`
			Match_status   string   `json:"match_status"`
			Is_whitelisted bool     `json:"is_whitelisted"`
		} `json:"hits"`
	} `json:"data"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "data":
			easyjsonD017d1f1Decode3(in, &out.Data)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD017d1f1Encode2(out *jwriter.Writer, in struct {
	Data struct {
		Id          int64  `json:"id"`
		Ref         string `json:"ref"`
		Searcher_id int64  `json:"searcher_id"`
		Assignee_id int64  `json:"assignee_id"`
		Filters     struct {
			Birth_year      int64    `json:"birth_year"`
			Country_codes   []int    `json:"country_codes"`
			Remove_deceased int      `json:"remove_deceased"`
			Types           []string `json:"types"`
			Exact_match     bool     `json:"exact_match"`
			Fuzziness       float64  `json:"fuzziness"`
		}
		Match_status   string   `json:"match_status"`
		Risk_level     string   `json:"risk_level"`
		Search_term    string   `json:"search_term"`
		Submitted_term string   `json:"submitted_term"`
		Client_ref     string   `json:"client_ref"`
		Total_hits     int      `json:"total_hits"`
		Updated_at     string   `json:"updated_at"`
		Created_at     string   `json:"created_at"`
		Tags           []string `json:"tags"`
		Limit          int      `json:"limit"`
		Offset         int      `json:"offset"`
		Share_url      string   `json:"share_url"`
		Hits           []struct {
			Doc struct {
				Aka []struct {
					Name string `json:"name"`
				} `json:"aka"`
				Assets []struct {
					Public_url string `json:"public_url"`
					Source     string `json:"source"`
					Type       string `json:"type"`
				} `json:"assets"`
				Entity_type string `json:"entity_type"`
				Fields      []struct {
					Name   string `json:"name"`
					Source string `json:"source"`
					Tag    string `json:"tag"`
					Value  string `json:"value"`
				} `json:"fields"`
				Id    string
				Media []struct {
					Date    string `json:"date"`
					Snippet string `json:"snippet"`
					Title   string `json:"title"`
					Url     string `json:"url"`
				} `json:"media"`
				Name    string   `json:"name"`
				Sources []string `json:"sources"`
				Types   []string `json:"types"`
			} `json:"doc"`
			Match_types    []string `json:"match_types"`
			Score          float64  `json:"score"`
			Match_status   string   `json:"match_status"`
			Is_whitelisted bool     `json:"is_whitelisted"`
		} `json:"hits"`
	} `json:"data"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"data\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		easyjsonD017d1f1Encode3(out, in.Data)
	}
	out.RawByte('}')
}
func easyjsonD017d1f1Decode3(in *jlexer.Lexer, out *struct {
	Id          int64  `json:"id"`
	Ref         string `json:"ref"`
	Searcher_id int64  `json:"searcher_id"`
	Assignee_id int64  `json:"assignee_id"`
	Filters     struct {
		Birth_year      int64    `json:"birth_year"`
		Country_codes   []int    `json:"country_codes"`
		Remove_deceased int      `json:"remove_deceased"`
		Types           []string `json:"types"`
		Exact_match     bool     `json:"exact_match"`
		Fuzziness       float64  `json:"fuzziness"`
	}
	Match_status   string   `json:"match_status"`
	Risk_level     string   `json:"risk_level"`
	Search_term    string   `json:"search_term"`
	Submitted_term string   `json:"submitted_term"`
	Client_ref     string   `json:"client_ref"`
	Total_hits     int      `json:"total_hits"`
	Updated_at     string   `json:"updated_at"`
	Created_at     string   `json:"created_at"`
	Tags           []string `json:"tags"`
	Limit          int      `json:"limit"`
	Offset         int      `json:"offset"`
	Share_url      string   `json:"share_url"`
	Hits           []struct {
		Doc struct {
			Aka []struct {
				Name string `json:"name"`
			} `json:"aka"`
			Assets []struct {
				Public_url string `json:"public_url"`
				Source     string `json:"source"`
				Type       string `json:"type"`
			} `json:"assets"`
			Entity_type string `json:"entity_type"`
			Fields      []struct {
				Name   string `json:"name"`
				Source string `json:"source"`
				Tag    string `json:"tag"`
				Value  string `json:"value"`
			} `json:"fields"`
			Id    string
			Media []struct {
				Date    string `json:"date"`
				Snippet string `json:"snippet"`
				Title   string `json:"title"`
				Url     string `json:"url"`
			} `json:"media"`
			Name    string   `json:"name"`
			Sources []string `json:"sources"`
			Types   []string `json:"types"`
		} `json:"doc"`
		Match_types    []string `json:"match_types"`
		Score          float64  `json:"score"`
		Match_status   string   `json:"match_status"`
		Is_whitelisted bool     `json:"is_whitelisted"`
	} `json:"hits"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "id":
			out.Id = int64(in.Int64())
		case "ref":
			out.Ref = string(in.String())
		case "searcher_id":
			out.Searcher_id = int64(in.Int64())
		case "assignee_id":
			out.Assignee_id = int64(in.Int64())
		case "Filters":
			easyjsonD017d1f1Decode4(in, &out.Filters)
		case "match_status":
			out.Match_status = string(in.String())
		case "risk_level":
			out.Risk_level = string(in.String())
		case "search_term":
			out.Search_term = string(in.String())
		case "submitted_term":
			out.Submitted_term = string(in.String())
		case "client_ref":
			out.Client_ref = string(in.String())
		case "total_hits":
			out.Total_hits = int(in.Int())
		case "updated_at":
			out.Updated_at = string(in.String())
		case "created_at":
			out.Created_at = string(in.String())
		case "tags":
			if in.IsNull() {
				in.Skip()
				out.Tags = nil
			} else {
				in.Delim('[')
				if out.Tags == nil {
					if !in.IsDelim(']') {
						out.Tags = make([]string, 0, 4)
					} else {
						out.Tags = []string{}
					}
				} else {
					out.Tags = (out.Tags)[:0]
				}
				for !in.IsDelim(']') {
					var v4 string
					v4 = string(in.String())
					out.Tags = append(out.Tags, v4)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "limit":
			out.Limit = int(in.Int())
		case "offset":
			out.Offset = int(in.Int())
		case "share_url":
			out.Share_url = string(in.String())
		case "hits":
			if in.IsNull() {
				in.Skip()
				out.Hits = nil
			} else {
				in.Delim('[')
				if out.Hits == nil {
					if !in.IsDelim(']') {
						out.Hits = make([]struct {
							Doc struct {
								Aka []struct {
									Name string `json:"name"`
								} `json:"aka"`
								Assets []struct {
									Public_url string `json:"public_url"`
									Source     string `json:"source"`
									Type       string `json:"type"`
								} `json:"assets"`
								Entity_type string `json:"entity_type"`
								Fields      []struct {
									Name   string `json:"name"`
									Source string `json:"source"`
									Tag    string `json:"tag"`
									Value  string `json:"value"`
								} `json:"fields"`
								Id    string
								Media []struct {
									Date    string `json:"date"`
									Snippet string `json:"snippet"`
									Title   string `json:"title"`
									Url     string `json:"url"`
								} `json:"media"`
								Name    string   `json:"name"`
								Sources []string `json:"sources"`
								Types   []string `json:"types"`
							} `json:"doc"`
							Match_types    []string `json:"match_types"`
							Score          float64  `json:"score"`
							Match_status   string   `json:"match_status"`
							Is_whitelisted bool     `json:"is_whitelisted"`
						}, 0, 1)
					} else {
						out.Hits = []struct {
							Doc struct {
								Aka []struct {
									Name string `json:"name"`
								} `json:"aka"`
								Assets []struct {
									Public_url string `json:"public_url"`
									Source     string `json:"source"`
									Type       string `json:"type"`
								} `json:"assets"`
								Entity_type string `json:"entity_type"`
								Fields      []struct {
									Name   string `json:"name"`
									Source string `json:"source"`
									Tag    string `json:"tag"`
									Value  string `json:"value"`
								} `json:"fields"`
								Id    string
								Media []struct {
									Date    string `json:"date"`
									Snippet string `json:"snippet"`
									Title   string `json:"title"`
									Url     string `json:"url"`
								} `json:"media"`
								Name    string   `json:"name"`
								Sources []string `json:"sources"`
								Types   []string `json:"types"`
							} `json:"doc"`
							Match_types    []string `json:"match_types"`
							Score          float64  `json:"score"`
							Match_status   string   `json:"match_status"`
							Is_whitelisted bool     `json:"is_whitelisted"`
						}{}
					}
				} else {
					out.Hits = (out.Hits)[:0]
				}
				for !in.IsDelim(']') {
					var v5 struct {
						Doc struct {
							Aka []struct {
								Name string `json:"name"`
							} `json:"aka"`
							Assets []struct {
								Public_url string `json:"public_url"`
								Source     string `json:"source"`
								Type       string `json:"type"`
							} `json:"assets"`
							Entity_type string `json:"entity_type"`
							Fields      []struct {
								Name   string `json:"name"`
								Source string `json:"source"`
								Tag    string `json:"tag"`
								Value  string `json:"value"`
							} `json:"fields"`
							Id    string
							Media []struct {
								Date    string `json:"date"`
								Snippet string `json:"snippet"`
								Title   string `json:"title"`
								Url     string `json:"url"`
							} `json:"media"`
							Name    string   `json:"name"`
							Sources []string `json:"sources"`
							Types   []string `json:"types"`
						} `json:"doc"`
						Match_types    []string `json:"match_types"`
						Score          float64  `json:"score"`
						Match_status   string   `json:"match_status"`
						Is_whitelisted bool     `json:"is_whitelisted"`
					}
					easyjsonD017d1f1Decode5(in, &v5)
					out.Hits = append(out.Hits, v5)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD017d1f1Encode3(out *jwriter.Writer, in struct {
	Id          int64  `json:"id"`
	Ref         string `json:"ref"`
	Searcher_id int64  `json:"searcher_id"`
	Assignee_id int64  `json:"assignee_id"`
	Filters     struct {
		Birth_year      int64    `json:"birth_year"`
		Country_codes   []int    `json:"country_codes"`
		Remove_deceased int      `json:"remove_deceased"`
		Types           []string `json:"types"`
		Exact_match     bool     `json:"exact_match"`
		Fuzziness       float64  `json:"fuzziness"`
	}
	Match_status   string   `json:"match_status"`
	Risk_level     string   `json:"risk_level"`
	Search_term    string   `json:"search_term"`
	Submitted_term string   `json:"submitted_term"`
	Client_ref     string   `json:"client_ref"`
	Total_hits     int      `json:"total_hits"`
	Updated_at     string   `json:"updated_at"`
	Created_at     string   `json:"created_at"`
	Tags           []string `json:"tags"`
	Limit          int      `json:"limit"`
	Offset         int      `json:"offset"`
	Share_url      string   `json:"share_url"`
	Hits           []struct {
		Doc struct {
			Aka []struct {
				Name string `json:"name"`
			} `json:"aka"`
			Assets []struct {
				Public_url string `json:"public_url"`
				Source     string `json:"source"`
				Type       string `json:"type"`
			} `json:"assets"`
			Entity_type string `json:"entity_type"`
			Fields      []struct {
				Name   string `json:"name"`
				Source string `json:"source"`
				Tag    string `json:"tag"`
				Value  string `json:"value"`
			} `json:"fields"`
			Id    string
			Media []struct {
				Date    string `json:"date"`
				Snippet string `json:"snippet"`
				Title   string `json:"title"`
				Url     string `json:"url"`
			} `json:"media"`
			Name    string   `json:"name"`
			Sources []string `json:"sources"`
			Types   []string `json:"types"`
		} `json:"doc"`
		Match_types    []string `json:"match_types"`
		Score          float64  `json:"score"`
		Match_status   string   `json:"match_status"`
		Is_whitelisted bool     `json:"is_whitelisted"`
	} `json:"hits"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"id\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.Id))
	}
	{
		const prefix string = ",\"ref\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Ref))
	}
	{
		const prefix string = ",\"searcher_id\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.Searcher_id))
	}
	{
		const prefix string = ",\"assignee_id\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.Assignee_id))
	}
	{
		const prefix string = ",\"Filters\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		easyjsonD017d1f1Encode4(out, in.Filters)
	}
	{
		const prefix string = ",\"match_status\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Match_status))
	}
	{
		const prefix string = ",\"risk_level\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Risk_level))
	}
	{
		const prefix string = ",\"search_term\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Search_term))
	}
	{
		const prefix string = ",\"submitted_term\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Submitted_term))
	}
	{
		const prefix string = ",\"client_ref\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Client_ref))
	}
	{
		const prefix string = ",\"total_hits\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int(int(in.Total_hits))
	}
	{
		const prefix string = ",\"updated_at\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Updated_at))
	}
	{
		const prefix string = ",\"created_at\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Created_at))
	}
	{
		const prefix string = ",\"tags\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Tags == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v6, v7 := range in.Tags {
				if v6 > 0 {
					out.RawByte(',')
				}
				out.String(string(v7))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"limit\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int(int(in.Limit))
	}
	{
		const prefix string = ",\"offset\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int(int(in.Offset))
	}
	{
		const prefix string = ",\"share_url\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Share_url))
	}
	{
		const prefix string = ",\"hits\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Hits == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v8, v9 := range in.Hits {
				if v8 > 0 {
					out.RawByte(',')
				}
				easyjsonD017d1f1Encode5(out, v9)
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}
func easyjsonD017d1f1Decode5(in *jlexer.Lexer, out *struct {
	Doc struct {
		Aka []struct {
			Name string `json:"name"`
		} `json:"aka"`
		Assets []struct {
			Public_url string `json:"public_url"`
			Source     string `json:"source"`
			Type       string `json:"type"`
		} `json:"assets"`
		Entity_type string `json:"entity_type"`
		Fields      []struct {
			Name   string `json:"name"`
			Source string `json:"source"`
			Tag    string `json:"tag"`
			Value  string `json:"value"`
		} `json:"fields"`
		Id    string
		Media []struct {
			Date    string `json:"date"`
			Snippet string `json:"snippet"`
			Title   string `json:"title"`
			Url     string `json:"url"`
		} `json:"media"`
		Name    string   `json:"name"`
		Sources []string `json:"sources"`
		Types   []string `json:"types"`
	} `json:"doc"`
	Match_types    []string `json:"match_types"`
	Score          float64  `json:"score"`
	Match_status   string   `json:"match_status"`
	Is_whitelisted bool     `json:"is_whitelisted"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "doc":
			easyjsonD017d1f1Decode6(in, &out.Doc)
		case "match_types":
			if in.IsNull() {
				in.Skip()
				out.Match_types = nil
			} else {
				in.Delim('[')
				if out.Match_types == nil {
					if !in.IsDelim(']') {
						out.Match_types = make([]string, 0, 4)
					} else {
						out.Match_types = []string{}
					}
				} else {
					out.Match_types = (out.Match_types)[:0]
				}
				for !in.IsDelim(']') {
					var v10 string
					v10 = string(in.String())
					out.Match_types = append(out.Match_types, v10)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "score":
			out.Score = float64(in.Float64())
		case "match_status":
			out.Match_status = string(in.String())
		case "is_whitelisted":
			out.Is_whitelisted = bool(in.Bool())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD017d1f1Encode5(out *jwriter.Writer, in struct {
	Doc struct {
		Aka []struct {
			Name string `json:"name"`
		} `json:"aka"`
		Assets []struct {
			Public_url string `json:"public_url"`
			Source     string `json:"source"`
			Type       string `json:"type"`
		} `json:"assets"`
		Entity_type string `json:"entity_type"`
		Fields      []struct {
			Name   string `json:"name"`
			Source string `json:"source"`
			Tag    string `json:"tag"`
			Value  string `json:"value"`
		} `json:"fields"`
		Id    string
		Media []struct {
			Date    string `json:"date"`
			Snippet string `json:"snippet"`
			Title   string `json:"title"`
			Url     string `json:"url"`
		} `json:"media"`
		Name    string   `json:"name"`
		Sources []string `json:"sources"`
		Types   []string `json:"types"`
	} `json:"doc"`
	Match_types    []string `json:"match_types"`
	Score          float64  `json:"score"`
	Match_status   string   `json:"match_status"`
	Is_whitelisted bool     `json:"is_whitelisted"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"doc\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		easyjsonD017d1f1Encode6(out, in.Doc)
	}
	{
		const prefix string = ",\"match_types\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Match_types == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v11, v12 := range in.Match_types {
				if v11 > 0 {
					out.RawByte(',')
				}
				out.String(string(v12))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"score\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Float64(float64(in.Score))
	}
	{
		const prefix string = ",\"match_status\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Match_status))
	}
	{
		const prefix string = ",\"is_whitelisted\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Bool(bool(in.Is_whitelisted))
	}
	out.RawByte('}')
}
func easyjsonD017d1f1Decode6(in *jlexer.Lexer, out *struct {
	Aka []struct {
		Name string `json:"name"`
	} `json:"aka"`
	Assets []struct {
		Public_url string `json:"public_url"`
		Source     string `json:"source"`
		Type       string `json:"type"`
	} `json:"assets"`
	Entity_type string `json:"entity_type"`
	Fields      []struct {
		Name   string `json:"name"`
		Source string `json:"source"`
		Tag    string `json:"tag"`
		Value  string `json:"value"`
	} `json:"fields"`
	Id    string
	Media []struct {
		Date    string `json:"date"`
		Snippet string `json:"snippet"`
		Title   string `json:"title"`
		Url     string `json:"url"`
	} `json:"media"`
	Name    string   `json:"name"`
	Sources []string `json:"sources"`
	Types   []string `json:"types"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "aka":
			if in.IsNull() {
				in.Skip()
				out.Aka = nil
			} else {
				in.Delim('[')
				if out.Aka == nil {
					if !in.IsDelim(']') {
						out.Aka = make([]struct {
							Name string `json:"name"`
						}, 0, 4)
					} else {
						out.Aka = []struct {
							Name string `json:"name"`
						}{}
					}
				} else {
					out.Aka = (out.Aka)[:0]
				}
				for !in.IsDelim(']') {
					var v13 struct {
						Name string `json:"name"`
					}
					easyjsonD017d1f1Decode7(in, &v13)
					out.Aka = append(out.Aka, v13)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "assets":
			if in.IsNull() {
				in.Skip()
				out.Assets = nil
			} else {
				in.Delim('[')
				if out.Assets == nil {
					if !in.IsDelim(']') {
						out.Assets = make([]struct {
							Public_url string `json:"public_url"`
							Source     string `json:"source"`
							Type       string `json:"type"`
						}, 0, 1)
					} else {
						out.Assets = []struct {
							Public_url string `json:"public_url"`
							Source     string `json:"source"`
							Type       string `json:"type"`
						}{}
					}
				} else {
					out.Assets = (out.Assets)[:0]
				}
				for !in.IsDelim(']') {
					var v14 struct {
						Public_url string `json:"public_url"`
						Source     string `json:"source"`
						Type       string `json:"type"`
					}
					easyjsonD017d1f1Decode8(in, &v14)
					out.Assets = append(out.Assets, v14)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "entity_type":
			out.Entity_type = string(in.String())
		case "fields":
			if in.IsNull() {
				in.Skip()
				out.Fields = nil
			} else {
				in.Delim('[')
				if out.Fields == nil {
					if !in.IsDelim(']') {
						out.Fields = make([]struct {
							Name   string `json:"name"`
							Source string `json:"source"`
							Tag    string `json:"tag"`
							Value  string `json:"value"`
						}, 0, 1)
					} else {
						out.Fields = []struct {
							Name   string `json:"name"`
							Source string `json:"source"`
							Tag    string `json:"tag"`
							Value  string `json:"value"`
						}{}
					}
				} else {
					out.Fields = (out.Fields)[:0]
				}
				for !in.IsDelim(']') {
					var v15 struct {
						Name   string `json:"name"`
						Source string `json:"source"`
						Tag    string `json:"tag"`
						Value  string `json:"value"`
					}
					easyjsonD017d1f1Decode9(in, &v15)
					out.Fields = append(out.Fields, v15)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "Id":
			out.Id = string(in.String())
		case "media":
			if in.IsNull() {
				in.Skip()
				out.Media = nil
			} else {
				in.Delim('[')
				if out.Media == nil {
					if !in.IsDelim(']') {
						out.Media = make([]struct {
							Date    string `json:"date"`
							Snippet string `json:"snippet"`
							Title   string `json:"title"`
							Url     string `json:"url"`
						}, 0, 1)
					} else {
						out.Media = []struct {
							Date    string `json:"date"`
							Snippet string `json:"snippet"`
							Title   string `json:"title"`
							Url     string `json:"url"`
						}{}
					}
				} else {
					out.Media = (out.Media)[:0]
				}
				for !in.IsDelim(']') {
					var v16 struct {
						Date    string `json:"date"`
						Snippet string `json:"snippet"`
						Title   string `json:"title"`
						Url     string `json:"url"`
					}
					easyjsonD017d1f1Decode10(in, &v16)
					out.Media = append(out.Media, v16)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "name":
			out.Name = string(in.String())
		case "sources":
			if in.IsNull() {
				in.Skip()
				out.Sources = nil
			} else {
				in.Delim('[')
				if out.Sources == nil {
					if !in.IsDelim(']') {
						out.Sources = make([]string, 0, 4)
					} else {
						out.Sources = []string{}
					}
				} else {
					out.Sources = (out.Sources)[:0]
				}
				for !in.IsDelim(']') {
					var v17 string
					v17 = string(in.String())
					out.Sources = append(out.Sources, v17)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "types":
			if in.IsNull() {
				in.Skip()
				out.Types = nil
			} else {
				in.Delim('[')
				if out.Types == nil {
					if !in.IsDelim(']') {
						out.Types = make([]string, 0, 4)
					} else {
						out.Types = []string{}
					}
				} else {
					out.Types = (out.Types)[:0]
				}
				for !in.IsDelim(']') {
					var v18 string
					v18 = string(in.String())
					out.Types = append(out.Types, v18)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD017d1f1Encode6(out *jwriter.Writer, in struct {
	Aka []struct {
		Name string `json:"name"`
	} `json:"aka"`
	Assets []struct {
		Public_url string `json:"public_url"`
		Source     string `json:"source"`
		Type       string `json:"type"`
	} `json:"assets"`
	Entity_type string `json:"entity_type"`
	Fields      []struct {
		Name   string `json:"name"`
		Source string `json:"source"`
		Tag    string `json:"tag"`
		Value  string `json:"value"`
	} `json:"fields"`
	Id    string
	Media []struct {
		Date    string `json:"date"`
		Snippet string `json:"snippet"`
		Title   string `json:"title"`
		Url     string `json:"url"`
	} `json:"media"`
	Name    string   `json:"name"`
	Sources []string `json:"sources"`
	Types   []string `json:"types"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"aka\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Aka == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v19, v20 := range in.Aka {
				if v19 > 0 {
					out.RawByte(',')
				}
				easyjsonD017d1f1Encode7(out, v20)
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"assets\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Assets == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v21, v22 := range in.Assets {
				if v21 > 0 {
					out.RawByte(',')
				}
				easyjsonD017d1f1Encode8(out, v22)
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"entity_type\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Entity_type))
	}
	{
		const prefix string = ",\"fields\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Fields == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v23, v24 := range in.Fields {
				if v23 > 0 {
					out.RawByte(',')
				}
				easyjsonD017d1f1Encode9(out, v24)
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"Id\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Id))
	}
	{
		const prefix string = ",\"media\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Media == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v25, v26 := range in.Media {
				if v25 > 0 {
					out.RawByte(',')
				}
				easyjsonD017d1f1Encode10(out, v26)
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"name\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Name))
	}
	{
		const prefix string = ",\"sources\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Sources == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v27, v28 := range in.Sources {
				if v27 > 0 {
					out.RawByte(',')
				}
				out.String(string(v28))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"types\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Types == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v29, v30 := range in.Types {
				if v29 > 0 {
					out.RawByte(',')
				}
				out.String(string(v30))
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}
func easyjsonD017d1f1Decode10(in *jlexer.Lexer, out *struct {
	Date    string `json:"date"`
	Snippet string `json:"snippet"`
	Title   string `json:"title"`
	Url     string `json:"url"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "date":
			out.Date = string(in.String())
		case "snippet":
			out.Snippet = string(in.String())
		case "title":
			out.Title = string(in.String())
		case "url":
			out.Url = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD017d1f1Encode10(out *jwriter.Writer, in struct {
	Date    string `json:"date"`
	Snippet string `json:"snippet"`
	Title   string `json:"title"`
	Url     string `json:"url"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"date\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Date))
	}
	{
		const prefix string = ",\"snippet\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Snippet))
	}
	{
		const prefix string = ",\"title\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Title))
	}
	{
		const prefix string = ",\"url\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Url))
	}
	out.RawByte('}')
}
func easyjsonD017d1f1Decode9(in *jlexer.Lexer, out *struct {
	Name   string `json:"name"`
	Source string `json:"source"`
	Tag    string `json:"tag"`
	Value  string `json:"value"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "name":
			out.Name = string(in.String())
		case "source":
			out.Source = string(in.String())
		case "tag":
			out.Tag = string(in.String())
		case "value":
			out.Value = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD017d1f1Encode9(out *jwriter.Writer, in struct {
	Name   string `json:"name"`
	Source string `json:"source"`
	Tag    string `json:"tag"`
	Value  string `json:"value"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"name\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Name))
	}
	{
		const prefix string = ",\"source\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Source))
	}
	{
		const prefix string = ",\"tag\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Tag))
	}
	{
		const prefix string = ",\"value\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Value))
	}
	out.RawByte('}')
}
func easyjsonD017d1f1Decode8(in *jlexer.Lexer, out *struct {
	Public_url string `json:"public_url"`
	Source     string `json:"source"`
	Type       string `json:"type"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "public_url":
			out.Public_url = string(in.String())
		case "source":
			out.Source = string(in.String())
		case "type":
			out.Type = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD017d1f1Encode8(out *jwriter.Writer, in struct {
	Public_url string `json:"public_url"`
	Source     string `json:"source"`
	Type       string `json:"type"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"public_url\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Public_url))
	}
	{
		const prefix string = ",\"source\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Source))
	}
	{
		const prefix string = ",\"type\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Type))
	}
	out.RawByte('}')
}
func easyjsonD017d1f1Decode7(in *jlexer.Lexer, out *struct {
	Name string `json:"name"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "name":
			out.Name = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD017d1f1Encode7(out *jwriter.Writer, in struct {
	Name string `json:"name"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"name\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Name))
	}
	out.RawByte('}')
}
func easyjsonD017d1f1Decode4(in *jlexer.Lexer, out *struct {
	Birth_year      int64    `json:"birth_year"`
	Country_codes   []int    `json:"country_codes"`
	Remove_deceased int      `json:"remove_deceased"`
	Types           []string `json:"types"`
	Exact_match     bool     `json:"exact_match"`
	Fuzziness       float64  `json:"fuzziness"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "birth_year":
			out.Birth_year = int64(in.Int64())
		case "country_codes":
			if in.IsNull() {
				in.Skip()
				out.Country_codes = nil
			} else {
				in.Delim('[')
				if out.Country_codes == nil {
					if !in.IsDelim(']') {
						out.Country_codes = make([]int, 0, 8)
					} else {
						out.Country_codes = []int{}
					}
				} else {
					out.Country_codes = (out.Country_codes)[:0]
				}
				for !in.IsDelim(']') {
					var v31 int
					v31 = int(in.Int())
					out.Country_codes = append(out.Country_codes, v31)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "remove_deceased":
			out.Remove_deceased = int(in.Int())
		case "types":
			if in.IsNull() {
				in.Skip()
				out.Types = nil
			} else {
				in.Delim('[')
				if out.Types == nil {
					if !in.IsDelim(']') {
						out.Types = make([]string, 0, 4)
					} else {
						out.Types = []string{}
					}
				} else {
					out.Types = (out.Types)[:0]
				}
				for !in.IsDelim(']') {
					var v32 string
					v32 = string(in.String())
					out.Types = append(out.Types, v32)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "exact_match":
			out.Exact_match = bool(in.Bool())
		case "fuzziness":
			out.Fuzziness = float64(in.Float64())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD017d1f1Encode4(out *jwriter.Writer, in struct {
	Birth_year      int64    `json:"birth_year"`
	Country_codes   []int    `json:"country_codes"`
	Remove_deceased int      `json:"remove_deceased"`
	Types           []string `json:"types"`
	Exact_match     bool     `json:"exact_match"`
	Fuzziness       float64  `json:"fuzziness"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"birth_year\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.Birth_year))
	}
	{
		const prefix string = ",\"country_codes\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Country_codes == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v33, v34 := range in.Country_codes {
				if v33 > 0 {
					out.RawByte(',')
				}
				out.Int(int(v34))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"remove_deceased\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int(int(in.Remove_deceased))
	}
	{
		const prefix string = ",\"types\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Types == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v35, v36 := range in.Types {
				if v35 > 0 {
					out.RawByte(',')
				}
				out.String(string(v36))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"exact_match\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Bool(bool(in.Exact_match))
	}
	{
		const prefix string = ",\"fuzziness\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Float64(float64(in.Fuzziness))
	}
	out.RawByte('}')
}
